#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  SonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           left,          tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port7,           ruka,          tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port8,           vverhvniz,     tmotorNone, openLoop)
#pragma config(Motor,  port9,           klesh,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          right,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

////////////// edet
void moving(int VL, int VR, int time){
	motor[port1]=VL;
	motor[port10]=VR;
	wait1Msec(time);
}

//////////////////////// vverh vniz ruka

void updown(int VU, int time)
{
	motor[port8]=VU;
	wait1Msec(time);
}

/////////////////////////////// vpered nazan ruka

void hand(int VH, int time)
{
	motor[port7]=VH;
	wait1Msec(time);
}

/////////////////////// cpusk do ypora

void arm()
{
	int t = 100000;
	resetMotorEncoder(ruka);
  while (t > 0)
  {
  	if (nMotorEncoder(ruka) < 180)
  		motor[ruka] = 20;
  	else
  		motor[ruka] = -20;
  	t -= 1;
  }
}

/////////////// kleshnya

void claw(int VC){
	motor[port9] = VC;
	wait1Msec(1000);


}

//////////////// rasvorachivaetsya na 180

void rasvorot(){
	moving(50, 50, 1000);
}

////////////// povorot na 90

void povorot(){
	moving(50, 50, 500);

}

///////////////////////// rasvorot + vosvraschenye po koordinatam

void retur(){
	rasvorot();
	moving(-25, 25, 1000);
	povorot();
	moving(-25, 25, 1000);
	arm();
	claw(-50);
	updown(50, 1000);
	rasvorot();
	moving(-25, 25, 500);




}

//////////////////////////// obschaya proga

void delo()
{	int v = 25;
	int t = 1;
	int timey = 0;
	while(t)
	{
	if (SensorValue[dgtl1]<20)
		{	arm();
			claw(50);
			updown(50, 1000);
			retur();
		}
	else
		{
		moving(50, 50, 500);
		}
		}
	}

/////////////// test sensora
void testsensor(){
	if (SensorValue[dgtl1]>20){
		moving(50, 50, 1000);

	}
}


task main()
{
	while (true){
		if (vexRt[Btn8U]){
				int f = 1;
				while (f == 1){
					if (vexRt[Btn7L]){
						f  =  0;
					}
					else{
						if (vexRt[Btn5D]){
							motor[left] = -50;
						}
						else if (vexRt[Btn5U]){
							motor[left] = 50;
						}
						else{
							Motor[left] = 0;
						}
						if (vexRt[Btn6U]){
							motor[right] = 50;
						}
						else if (vexRt[Btn6D]){
							motor[right] = -50;
						}
						else{
							Motor[right] = 0;
							motor[left] = 0;
					}
						if (vexRT[Btn7U]){
							motor[vverhvniz] = 50;
						}
						if (vexRT[Btn7D]){
							motor[vverhvniz] = -50;
						}
						motor[klesh] = vexRT[Ch3];
						motor[ruka] = vexRt[Ch2];
				}
				if (f == 0){
					motor[right] = 0;
					motor[left] = 0;
				}
			}
		}
	}
}
